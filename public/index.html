
<!DOCTYPE html>
<html lang="en">
<head>
	<title>Battle Arena: Keybord/Mouse</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		@font-face { font-family: Arcade; 
			src: url('font/ArcadeClassic.ttf')
		} 

		html, body {
			width: 100%;
			height: 100%;
		}

		body {
			background-color: #ffffff;
			margin: 0;
			overflow: hidden;
			font-family: Arcade;
		}

		#blocker {

			position: absolute;

			width: 100%;
			height: 100%;

			background-color: rgba(0,0,0,0.5);

		}

		#instructions {

			width: 100%;
			height: 100%;

			display: -webkit-box;
			display: -moz-box;
			display: box;

			-webkit-box-orient: horizontal;
			-moz-box-orient: horizontal;
			box-orient: horizontal;

			-webkit-box-pack: center;
			-moz-box-pack: center;
			box-pack: center;

			-webkit-box-align: center;
			-moz-box-align: center;
			box-align: center;

			color: #ffffff;
			text-align: center;

			cursor: pointer;

		}

	</style>

	<script type="text/javascript" src="js/three.js"></script>

	<script type="text/javascript" src="js/originated/FireballShader.js"></script>
	<script type="text/javascript" src="js/originated/SuperFireballShader.js"></script>

	<script type="text/javascript" src="js/originated/HUD.js"></script>

	<script type="text/javascript" src="js/loader/MTLLoader.js"></script>
	<script type="text/javascript" src="js/loader/OBJLoader.js"></script>

	<script src="js/GPUParticleSystem.js" charset="utf-8"></script>

	<script src="js/modified/PointerLockControls.js"></script>
	<script src="js/socket.io.js"></script>

	<script type="text/javascript" src="js/physi.js"></script>

	<script type="text/javascript" src = "js/Audio.js"></script>
	<script type="text/javascript" src="http://www.smartjava.org/ltjs/libs/jquery-1.9.0.js"></script>
	<script type="text/javascript">

		'use strict';

		Physijs.scripts.worker = '/js/physijs_worker.js';
		Physijs.scripts.ammo = '/js/ammo.js';

		function playerinfo(){
			this.name = "ghost";
			this.pos;
			this.dir;
			this.rotHead;
			this.angularV;
			this.model;
			this.rot;
			this.job;
			this.shieldPos;
			this.hp = 100;
			this.score = 0;
		}
		var status = "waiting"//playing,waiting
		var myselfinfo = new playerinfo();
		var hitboxSelf;
		var spellInfo = {speed :50 , size : 5, damage : 10 , mass:10};//type 0 = fireball
		var socket = io();
		var movingSpells = [];
		var movingCores = [];
		var spellOnHand = [];
		var players = [];
		var treesPos;
		var job ="";
		var cooldown = 300;
		var cooldownTime = 400;
		var fireFocus = false;
		var clock = new THREE.Clock(true);
		var playWhenLoaded = function(){
		    //this.loop = true;
		   	//this.play();
		    //console.log(this);
		};

		var spawnerOptions, particleSystem;
		var tick=0;
		var options = {
				position: new THREE.Vector3(),
				positionRandomness: 6,
				velocity: new THREE.Vector3(),
				velocityRandomness: 6,
				color: 0xAA4000,
				colorRandomness: .3,
				turbulence: .5,
				lifetime: 1,
				size: 15,
				sizeRandomness: 2
			};
			spawnerOptions = {
				spawnRate: 1000,
				horizontalSpeed: 0,
				verticalSpeed: 0,
				timeScale: 1
			};
		var options2 = {
				position: new THREE.Vector3(),
				positionRandomness: 90,
				velocity: new THREE.Vector3(),
				velocityRandomness: 40000,
				color: 0xAA4000,
				colorRandomness: .3,
				turbulence: .5,
				lifetime: 3,
				size: 25,
				sizeRandomness: 2
			};
			var spawnerOptions2 = {
				spawnRate: 3000,
				horizontalSpeed: 1.5,
				verticalSpeed: 1.33,
				timeScale: 1
			};
		var options3 = {
				position: new THREE.Vector3(),
				positionRandomness: 20,
				velocity: new THREE.Vector3(),
				velocityRandomness: 400,
				color: 0xEEEEEE,
				colorRandomness: .3,
				turbulence: .5,
				lifetime: 3,
				size: 5,
				sizeRandomness: 2
			};



		$(document).ready(function(){

        //tell server
        //socket.emit("add user",'dude');

        socket.on('add user',function(data){
        	//console.log('new comer');
        });

        socket.on('respawn',function(data){
        	players = data;
        });

        socket.on('init_environment',function(data){
        	//console.log('new comer');
        	treesPos = data;
        });

        socket.on('add self',function(data){
        	
        	myselfinfo.name = data.name;
        	//controls.getObject().position.x = 100;
        	controls.getObject().position.x = data.pos[0];
        	controls.getObject().position.z = data.pos[1];
        	//controls.getObject().position.y = 100;
        	myselfinfo.pos = controls.getObject().position;
        	myselfinfo.dir = controls.getDirection();
        	myselfinfo.rot = controls.getRotation();
        	myselfinfo.rotHead = controls.getRotationPitch();
        	myselfinfo.pitch = controls.getRotationPitch();
        	myselfinfo.job = 'mage';
        	//myselfinfo.job = 'warrior';
        	controls.getObjectPitch().name = data;
        	createSelf();
        	status = "playing";
        	socket.emit('self added',myselfinfo);
        });


        socket.on('add others',function(data){

        	data.forEach(function(entry) {
        		console.log("adding others");
        		addPlayers(entry);
        	});

        });

   

        socket.on('add this player',function(data){
        console.log("adding new player");
        hud.log('new comer: ' + data.name);
        		
        	addPlayers(data);
        	
        });

        socket.on('moving',function(data){
        	movePlayers(data);
        });

        socket.on('show score',function(data){
        	hud.updateScore(data);
        	//data.forEach(function(item,index,object){
        	//	console.log(item.name + ": " + item.score);
        	//});
        });

        socket.on('player die', function(data){
        	hud.log(data.killer + ' killed ' + data.name, "red", data.name);
        	removePlayer(data);
        });

        socket.on('player left',function(data){
        	hud.log(data.name + " left!","red",data.name);
        	removePlayer(data);
        });

        //
      	socket.on('castSpell',function(data){
        	castSpell(data.name,data.size);
        });

      	socket.on('releaseSpell',function(data){
        	releaseSpell(data.name,data.speed,data.dir,data.id);
        });
  		socket.on('releaseSuperSpell',function(data){
  			//console.log(data);
        	releaseSuperSpell(data.name,data.x,data.z);
        });

    });
</script>
</head>
<body>
<script>
	
</script>

<div style="position: absolute;" id="camera2"></div>
	
	<div id="blocker">

		<div id="instructions" >
		<div id="statingPage" style="padding: 50px;">
			<span >
				<h1>Wellcome !</h1>
				<input type="text" name="game_btn" id="playerNameInput" placeholder="You name"></input>
				<select id="job_select">
					<option value ="mage">Mage</option>
				</select>
				<button  id="play_btn">PLAY</button>
				<hr />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around, E, F = Spells)
			</span>
		</div>

		<div id="continuePage" style="padding: 50px;display: none">
			<span>
				<h1>Waiting</h1>
				<button name="game_btn" id="continue_btn">Continue</button>
				<hr />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
			</span>
		</div>



		</div>

	</div>

	<script>
		var treeFlag = 0;
		var readyFlag = 0;
		var skyFaces = new Array();

		var camera,cameraHUD, sceneHUD, renderer,renderer2, composer;
		var scene = new Physijs.Scene;
		var geometry, material, mesh;
		var warriorHead, warriorBody, warriorShield;
		var trees = [];
		var fxaa;
		var fireballMat, superFireballMat;
		var fireShader, superFireShader;
		var floor;
		var magicCircle;
		var controls;
		var intersecPoint;
		var objects = new THREE.Group();
		var waitingCameraGroup;

		

		var raycaster;

		var blocker = document.getElementById( 'blocker' );
		var instructions = document.getElementById( 'instructions' );
		var play_btn = document.getElementById( 'play_btn' );
		var continue_btn = document.getElementById('continue_btn');
		var statingPage = document.getElementById( 'statingPage' );
		var continuePage = document.getElementById( 'continuePage' );
		var playerNameInput = document.getElementById( 'playerNameInput' );
		var job_select =  document.getElementById('job_select');
		var loading = true;
		var count = 0;
		inportModels();

		var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

		if ( havePointerLock ) {

			var element = document.body;

			var pointerlockchange = function ( event ) {

				if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

					controlsEnabled = true;
					controls.enabled = true;

					blocker.style.display = 'none';
					console.log("come back");
				} else {

					controls.enabled = false;

					blocker.style.display = '-webkit-box';
					blocker.style.display = '-moz-box';
					blocker.style.display = 'box';

					instructions.style.display = '';

					if(status =="dead"){
					continuePage.style.display = 'none';
					statingPage.style.display = '';
					}else{
					continuePage.style.display = '';
					statingPage.style.display = 'none';
					}
					console.log("waiting");

				}

			};

			var pointerlockerror = function ( event ) {

				instructions.style.display = '';
				console.log("error page");

			};

			// Hook pointer lock state change events
			document.addEventListener( 'pointerlockchange', pointerlockchange, false );
			document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
			document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

			document.addEventListener( 'pointerlockerror', pointerlockerror, false );
			document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
			document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

			continue_btn.addEventListener('click',gameClick, false );

			play_btn.addEventListener( 'click', gameClick, false );

		} else {
			instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
			//document.addEventListener( 'click', mouseClicked, false );
		}

		function gameClick( event ) {
				if(this.id == "play_btn"){
					var name = "guest";
					if(playerNameInput.value != "" )
						name = playerNameInput.value;
						socket.emit("add user",{name: name , job:job_select.value});
				}

				players.forEach(function(item,index,object){
					console.log(item.name);
				})

				instructions.style.display = 'none';

				// Ask the browser to lock the pointer
				element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

				if ( /Firefox/i.test( navigator.userAgent ) ) {

					var fullscreenchange = function ( event ) {

						if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

							document.removeEventListener( 'fullscreenchange', fullscreenchange );
							document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

							element.requestPointerLock();
						}

					};

					document.addEventListener( 'fullscreenchange', fullscreenchange, false );
					document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

					element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

					element.requestFullscreen();

				} else {

					element.requestPointerLock();

				}

		}
		var hud;
		
		
		
		

		var controlsEnabled = false;

		var moveForward = false;
		var moveBackward = false;
		var moveLeft = false;
		var moveRight = false;
		var jump = false;
		var canJump = true;

		var prevTime = performance.now();
		var velocity = new THREE.Vector3();
		var waitingCamera ;
		
function init() {


	readyFlag = 1;
	camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 5.5, 8000 );
	var width = window.innerWidth;
	var height = window.innerHeight;
	waitingCameraGroup = new THREE.Group();
	waitingCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 5.5, 8000 );
	waitingCamera.position.y = 300;
	waitingCamera.position.x = 200;
	waitingCamera.lookAt(new THREE.Vector3(0,0,0));
	waitingCameraGroup.add(waitingCamera);
	scene.add(waitingCameraGroup);

	//scene = new THREE.Scene();
	//scene = new Physijs.Scene;
	//scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
	scene.fog = new THREE.FogExp2( 0x404040, 0.0007 );

	scene.add(new THREE.AmbientLight(0x404040 ));
	scene.add(objects);
	hemiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.5 );
				scene.add( hemiLight );

	var light = new THREE.DirectionalLight( 0xffffff, 0.2);
	light.castShadow = true;

	light.position.set(310 ,440 ,400 );
	light.target.position.set( 0, 0, 0 );
	light.shadow.mapSize.width = 500;
    light.shadow.mapSize.height = 500;
    light.shadow.camera.near = 150;
    light.shadow.camera.top = 500;
    light.shadow.camera.bottom = -500;
    light.shadow.camera.left = -500;
    light.shadow.camera.right = 500;
    light.shadow.camera.far = 1000;
    light.shadow.camera.fov = 500;
	scene.add(light);

	fireShader = THREE.FireballShader;
	fireballMat = new THREE.ShaderMaterial( fireShader );
	superFireShader = THREE.SuperFireballShader;
	superFireballMat = new THREE.ShaderMaterial( superFireShader );

	controls = new THREE.PointerLockControls( camera );



		scene.add( controls.getObject() );

			particleSystem = new THREE.GPUParticleSystem({
				maxParticles: 250000
			});
			scene.add( particleSystem);


		var tabPressed = false;
		var onKeyDown = function ( event ) {
			
			//socket.emit('moving',{key: event.keyCode, name: myselfinfo.name});
			switch ( event.keyCode ) {
					case 38: // up
					case 87: // w
					moveForward = true;
					//hitboxSelf.setLinearVelocity(controls.getMoveDirection().multiplyScalar(100));
					break;

					case 37: // left
					case 65: // a
					moveLeft = true;
					break;

					case 40: // down
					case 83: // s
					moveBackward = true;
					//hitboxSelf.setLinearVelocity(new THREE.Vector3(0, 0, 0).sub(controls.getMoveDirection()).multiplyScalar(100));
					break;

					case 39: // right
					case 68: // d
					moveRight = true;
					break;

					case 32: // space
					// if ( canJump === true ){
						jump = true;
					// }
					// canJump = false;
					break;

					case 9:
					if (tabPressed == false) {
						tabPressed = true;
						socket.emit("show score");
					}
					break;
				}

			};

			var onKeyUp = function ( event ) {

				switch( event.keyCode ) {

					case 38: // up
					case 87: // w
					moveForward = false;
					//hitboxSelf.setLinearVelocity(new THREE.Vector3(0,0,0));
					break;

					case 37: // left
					case 65: // a
					moveLeft = false;
					break;

					case 40: // down
					case 83: // s
					moveBackward = false;
					//hitboxSelf.setLinearVelocity(new THREE.Vector3(0,0,0));
					break;

					case 39: // right
					case 68: // d
					moveRight = false;
					break;

					case 9:
						tabPressed = false;
					break;

				}
				if(!moveRight&&!moveBackward&&!moveLeft&&!moveForward){
					if(hitboxSelf!= null) hitboxSelf.setLinearVelocity(new THREE.Vector3(0,0,0));
				}

			};

			document.addEventListener( 'keydown', onKeyDown, false );
			document.addEventListener( 'keyup', onKeyUp, false );

			raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 16 );

			// floor

			geometry = new THREE.BoxGeometry( 4200 ,4200, 5 );
			floorGeom = new THREE.BoxGeometry( 1024,10,1024 );
			geometry.rotateX( - Math.PI / 2 );
			//floorGeom.rotateX( - Math.PI / 2 );

			material = new THREE.MeshLambertMaterial({color: 0x56b000, transparent: true, opacity: 0});

			var floorTexture = new THREE.ImageUtils.loadTexture('textures/floor.png' );
			floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
			floorTexture.repeat.set( 20, 20 );
			// var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );

 			var floorMaterial = new THREE.MeshStandardMaterial({
 				roughness : 0.8,
 				map: floorTexture

 			});

			floorMat = Physijs.createMaterial(
				floorMaterial,
			.8, // high friction
			.4 // low restitution
			);

			//floor = new THREE.Mesh( floorGeom, material );
			floor = new Physijs.BoxMesh(
				floorGeom,
				floorMat,
			0 //mass
			);
			floor.name = "floor";
			floor.position.y -= 5;
			floor.receiveShadow = true;
			scene.add( floor );
			//scene.add(sound);


				//skybox
				var skyMaterial = new THREE.MeshFaceMaterial( skyFaces );
//skyMaterial.side = THREE.BackSide;
var skybox = new THREE.Mesh(new THREE.CubeGeometry( 4096, 4096, 4096), skyMaterial);
skybox.rotation.x = - Math.PI / 2;
scene.add(skybox);
//boundaries
var leftPlane = new Physijs.BoxMesh (geometry, material, 0);
leftPlane.rotation.x += Math.PI/2;
leftPlane.position.z += 2100;
scene.add(leftPlane);

var rightPlane = new Physijs.BoxMesh (geometry, material, 0);
rightPlane.rotation.x += Math.PI/2;
rightPlane.position.z -= 2100;
scene.add(rightPlane);

var fontPlane = new Physijs.BoxMesh (geometry, material, 0);
fontPlane.rotation.z += Math.PI/2;
fontPlane.position.x += 2100;
scene.add(fontPlane);

var backPlane = new Physijs.BoxMesh (geometry, material, 0);
backPlane.rotation.z += Math.PI/2;
backPlane.position.x -= 2100;
scene.add(backPlane);

var topPlane = new Physijs.BoxMesh (geometry, material, 0);
topPlane.position.y += 2100;
scene.add(topPlane);
//topPlane.rotation.x += Math.PI/2;


var botPlane = new Physijs.BoxMesh(geometry, material , 0);
botPlane.name = "fall";
botPlane.position.y -= 2000;
scene.add(botPlane);
//topPlane.rotation.x += Math.PI/2;


renderer = new THREE.WebGLRenderer({ antialias: false});
renderer.autoClear = false;
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;
renderer.shadowMap.soft = true;
renderer.shadowMap.type = THREE.BasicShadowMap;

// renderer2 = new THREE.WebGLRenderer({ antialias: false});
// renderer2.autoClear = false;
//  renderer2.setPixelRatio( window.devicePixelRatio * 0.7 );
// renderer2.setViewport(0, 0, 100, 100 );
// renderer2.setScissor( 0, 0, 100, 100 );

//document.getElementById( 'camera2' ).appendChild(renderer2.domElement );;

document.body.appendChild( renderer.domElement );

	//postprocessing
	// composer = new THREE.EffectComposer( renderer );
	// composer.addPass( new THREE.RenderPass( scene, camera ) );

	// composer.addPass( new THREE.BloomPass( 0.45 ) );


	// film = new THREE.FilmPass( 0.15, 0.15, 2048, false );
	// film.renderToScreen = true;
	// composer.addPass( film );


	//fxaa = new THREE.ShaderPass( THREE.FXAAShader );
	// //fxaa.renderToScreen = true;
	// fxaa.uniforms.resolution.value.set( 1 / window.innerWidth, 1 / window.innerHeight );
	// console.log('!!!!!!!!' + window.innerWidth);
	//composer.addPass( fxaa );


	window.addEventListener( 'resize', onWindowResize, false );

}

function onWindowResize() {

	var width = window.innerWidth;
	var height = window.innerHeight;

	camera.aspect = width/height;
	camera.updateProjectionMatrix();

	hud.resize(width,height);

	//fxaa.uniforms.resolution.value.set( 1 / width, 1 / height );
	//healthBar.geometry.verticesNeedUpdate = false;

	renderer.setSize( width, height );
		//composer.setSize( width, height );

	}

	function animate() {

		requestAnimationFrame( animate );
		var delta3 = clock.getDelta() * spawnerOptions.timeScale;



		if (controlsEnabled && status =="playing") {

			//for focus


			raycaster.ray.origin.copy( hitboxSelf.position );
			//raycaster.ray.origin.y -= 15;

			var intersections = raycaster.intersectObjects(scene.children);

				//	if ( moveForward &&intersections)console.log(intersections[0]);
			var isOnObject = intersections.length > 0;

			// velocity.x -= velocity.x * 10.0 * delta;
			// velocity.z -= velocity.z * 10.0 * delta;

			//velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

				// var speed = 2000;
			// if(isOnObject){
			// 	if(jump){
			// 		console.log("jumpjii");
			// 		hitboxSelf.applyCentralForce(new THREE.Vector3(0,10000,0));
			// 		jump = false;
			// 	}
			// }else{
			// 	if(hitboxSelf.position.y >= 100){
			// 		hitboxSelf.applyCentralForce(new THREE.Vector3(0,-10000,0));
			// 	}
			// }
				var dir = new THREE.Vector3(0,0,0);
				var ySpeed = hitboxSelf.getLinearVelocity().y;
				if ( moveBackward ){
					dir = controls.getMoveDirection().negate();
					if ( moveLeft ) dir.applyAxisAngle ( new THREE.Vector3(0,1,0), -Math.PI/4 );
					if ( moveRight ) dir.applyAxisAngle ( new THREE.Vector3(0,1,0), Math.PI/4 );
				}else if ( moveForward ){
					dir = controls.getMoveDirection();
					if ( moveLeft ) dir.applyAxisAngle ( new THREE.Vector3(0,1,0), Math.PI/4 );
					if ( moveRight ) dir.applyAxisAngle ( new THREE.Vector3(0,1,0), -Math.PI/4 );
				}else{
					if ( moveLeft ) dir = controls.getMoveDirection().applyAxisAngle ( new THREE.Vector3(0,1,0), Math.PI/2 );
					if ( moveRight ) dir = controls.getMoveDirection().applyAxisAngle ( new THREE.Vector3(0,1,0), -Math.PI/2 );
				}
				if(isOnObject && jump){
					dir.setY(0.8);
				}else if(!isOnObject){
					jump = false;
					dir.setY(ySpeed/50 - 0.012);
				}

				if(true){
					hitboxSelf.setLinearVelocity(dir.multiplyScalar(50));
				}


				//console.log();
				if (true) {
					socket.emit('moved', {pos : controls.getObject().position, rotHead: controls.getRotationPitch(), 
						rot : controls.getRotation(), shieldPos : myselfinfo.shieldPos});
				};

				
				cooldown += 1;
				if(cooldown>cooldownTime)
					cooldown=cooldownTime;
				
			




			//partical system starts from here


			if(fireFocus){
				var ray = new THREE.Raycaster( controls.getObject().position, 
					controls.getDirection());
				intersecPoint = ray.intersectObjects([floor]);
				if(intersecPoint[0] != null){

					var intersectX = intersecPoint[0].point.x;
					var intersectZ = intersecPoint[0].point.z;

					magicCircle.position.copy(new THREE.Vector3(intersectX,0.1,intersectZ));

					var segmentCount = 32,radius =60;
					for (var i = 0; i <= segmentCount; i++) {
						var theta = (i / segmentCount) * Math.PI * 2;
						;
						
						if (delta3 > 0) {

							options.position.x = Math.cos(theta) * radius + intersectX;
							options.position.y = 2;
							options.position.z = Math.sin(theta) * radius + intersectZ;
							for (var x = 0; x < spawnerOptions.spawnRate * delta3; x++) {
								particleSystem.spawnParticle(options);
							}

						}       
					}

				}else{
					magicCircle.position.y = -1000;
				}
			}

			//particleSystem.update(tick);
			//end particleSystem

				// var tmp = controls.getObject();
				// tmp.translateX( velocity.x * delta );
				// tmp.translateY( velocity.y * delta );
				// tmp.translateZ( velocity.z * delta );
				// var targetPos = new THREE.Vector3(tmp.position.x,tmp.position.y,tmp.position.z);
				// controls.getObject().setLinearVelocity(targetPos.sub(controls.getObject().position).multiplyScalar(15));

				// controls.getObject().translateX( velocity.x * delta );
				// controls.getObject().translateY( velocity.y * delta );
				// controls.getObject().translateZ( velocity.z * delta );
				//hitboxSelf.__dirtyPosition = true;
				//hitboxSelf.position.copy(controls.getObject().position);
				//var targetPos = new THREE.Vector3(controls.getObject().position.x,controls.getObject().position.y+10,controls.getObject().position.z);
				//hitboxSelf.setLinearVelocity(targetPos.sub(hitboxSelf.position).multiplyScalar(15));
				//hitboxSelf.rotation = controls.getObject().rotation;
				hitboxSelf.setAngularVelocity(new THREE.Vector3(0,0,0));
				hitboxSelf.__dirtyRotation = true;
				hitboxSelf.rotation.copy(controls.getObject().rotation);
				//hitboxSelf.setAngularVelocity(controls.getDirection());

				controls.getObject().position.copy(hitboxSelf.position);

			}

				//particleSystem for all
			
			tick += delta3;
			if (tick < 0) tick = 0;
			
			movingSpells.forEach(function(item,index,object){
				if (delta3 > 0) {
					if(item.name=="fireball"){
						options.position.x = item.position.x;
						options.position.y = item.position.y;
						options.position.z = item.position.z;
						for (var x = 0; x < spawnerOptions.spawnRate * delta3; x++) {
							particleSystem.spawnParticle(options);
						}
					}
					var tmp = options2.positionRandomness;
					var tmpSize = options2.size;
					
					if(item.name=="superFireball"){
						
						options2.position.x = item.position.x;
						options2.position.y = item.position.y;
						options2.position.z = item.position.z;
						options2.positionRandomness = item.children[0].scale.x * tmp;
						//console.log(item.children[0].scale.x);
						options2.size = item.children[0].scale.x * tmpSize;
						for (var x = 0; x < spawnerOptions2.spawnRate * delta3; x++) {
							particleSystem.spawnParticle(options2);
						}
						
					}
					options2.positionRandomness = tmp;
					options2.size = tmpSize;
					
				}
			});

			movingCores.forEach(function(item,index,object){
				if(myselfinfo.pos != null && item.position.distanceTo(myselfinfo.pos) <= 60*item.children[0].scale.x ){
		  		//socket.emit('hit', );
		  			myselfinfo.hp -= item.damage;
		  			if(myselfinfo.hp <= 0 && status != "dead"){
		  				iDie(item.owner);
		  			}
		  		}

		  			  		//test
		  		movingSpells.forEach(function(item2,index2,object2){
		  			if(item.position.distanceTo(item2.position) <= 60*item.children[0].scale.x && item2.name!="superFireball"){
			  			movingSpells.splice(index2, 1);
			  			scene.remove(item2);
			  			item.children[0].scale.x += 0.1;
			  			item.children[0].scale.y += 0.1;
			  			item.children[0].scale.z += 0.1;
			  		}
		  		});
		  		//end test
		  		
		  	});
			particleSystem.update(tick);
			//partical system ends here now
			scene.simulate();
			
			if(status != "waiting"){
				renderer.render( scene, camera );
				hud.render(players,myselfinfo);

			}else{
				waitingCameraGroup.rotation.y += 0.002;
				renderer.render( scene, waitingCamera);
			}
			
			var delta2 = clock.getDelta();
			fireShader.uniforms.iGlobalTime.value += delta2;
			superFireShader.uniforms.iGlobalTime.value += delta2;
			//renderer.render( sceneHUD, cameraHUD);

		}

		function inportModels(){
			// model
			var onProgress = function ( xhr ) {
				if ( xhr.lengthComputable ) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log( Math.round(percentComplete, 2) + '% downloaded' );
					if(xhr.loaded == xhr.total){
						count ++;
						console.log("loadingadasdasd " + count);

					}
					if(count == 30){
						console.log(count);
						init();
						hud = new HUD(renderer)
						hud.init();

						animate();
						socket.emit("loading finished");
					}
				}
			};

			var onError = function ( xhr ) {
				console.log('error!');
			};

	//inport warrior
	var warriorLoader = new THREE.MTLLoader();
	warriorLoader.setBaseUrl( 'models/warrior/' );
	warriorLoader.setPath( 'models/warrior/' );
	warriorLoader.load( 'warrior_head.mtl', function( materials ) {
		materials.preload();

		var objLoader = new THREE.OBJLoader();
		objLoader.setMaterials( materials );
		objLoader.setPath( 'models/warrior/' );

		objLoader.load( 'warrior_head.obj', function ( object ) {
			//object.scale.set(0.5,0.5,0.5);
			
		//controls.getObjectPitch().add(object);
		//object.position.z += 1.5;
		object.position.y += 33;
		object.traverse( function( node ) { if ( node instanceof THREE.Mesh ) { node.castShadow = true; node.receiveShadow = true;} } );
		warriorHead = object.clone();
		warriorHead.name = 'head';
		
		


	}, onProgress, onError );
	}, onProgress, onError);
	var warriorLoader = new THREE.MTLLoader();
	warriorLoader.setBaseUrl( 'models/warrior/' );
	warriorLoader.setPath( 'models/warrior/' );
	warriorLoader.load( 'warrior_body.mtl', function( materials ) {
		materials.preload();

		var objLoader = new THREE.OBJLoader();
		objLoader.setMaterials( materials );
		objLoader.setPath( 'models/warrior/' );

		objLoader.load( 'warrior_body.obj', function ( object ) {
			object.scale.set(0.5,0.5,0.5);
			
		//controls.getObject().add(object);
		//object.position.z -= 100;
		object.position.y -= 20.5;
		object.traverse( function( node ) { if ( node instanceof THREE.Mesh ) { node.castShadow = true; node.receiveShadow = true;} } );
		warriorBody = object.clone();
		warriorBody.name = 'body';
		
		//objects.add(warriorBody.clone());


	}, onProgress, onError );
	}, onProgress, onError);

	var warriorLoader = new THREE.MTLLoader();
	warriorLoader.setBaseUrl( 'models/warrior/' );
	warriorLoader.setPath( 'models/warrior/' );
	warriorLoader.load( 'shield.mtl', function( materials ) {
		materials.preload();

		var objLoader = new THREE.OBJLoader();
		objLoader.setMaterials( materials );
		objLoader.setPath( 'models/warrior/' );

		objLoader.load( 'shield.obj', function ( object ) {
			object.scale.set(0.5,0.5,0.5);
			
		//controls.getObject().add(object);
		//object.position.z -= 100;
		object.rotation.y -= Math.PI/2;
		object.position.z = -6.5;
		object.position.x = -3.5;
		object.position.y = -15;
		warriorShield = object.clone();
		warriorShield.position.z += 10;
		warriorShield.name = 'shield';

		//objects.add(warriorBody.clone());


	}, onProgress, onError );
	}, onProgress, onError);

	inportPlants();

	var loader = new THREE.TextureLoader();

	var skyTexture = new Array()
	skyTexture[0] = loader.load('textures/skyxneg.jpg');
	skyTexture[1] = loader.load('textures/skyxpos.jpg');
	skyTexture[2] = loader.load('textures/skyypos.jpg');
	skyTexture[3] = loader.load('textures/skyyneg.jpg');
	skyTexture[4] = loader.load('textures/skyzpos.jpg');
	skyTexture[5] = loader.load('textures/skyzneg.jpg');
	skyFaces = new Array();

	for(var i = 0; i<6; i++){
		skyFaces[i] = new THREE.MeshBasicMaterial({
			map: skyTexture[i],
			side: THREE.BackSide});
	}

	loader.load(
	// resource URL
	'textures/magic_circle.png',
	// Function when resource is loaded
	function ( texture ) {
		var material = new THREE.MeshBasicMaterial({map : texture, transparent: true});
		magicCircle = new THREE.Mesh(new THREE.PlaneGeometry(120, 120), material);
		magicCircle.rotation.x -= Math.PI/2;
		//sceneHUD.add( crosshair );
		
	});

	function inportPlants(){
		var plantNames = new Array( 'berry', 'brightbell', 'silkweed', 'forstsnap');
		var plantNamesTemp = new Array;
		var k = -1;

		for(var j=0; j<plantNames.length; j++){
			var mtlLoader = new THREE.MTLLoader();
			mtlLoader.setBaseUrl( 'models/' );
			mtlLoader.setPath( 'models/' );
			plantNamesTemp.push(plantNames[j]);
			//console.log(plantNames[j] + '.mtl loading');
			mtlLoader.load( plantNames[j] + '.mtl', function( materials ) {
				materials.preload();

				var objLoader = new THREE.OBJLoader();
				objLoader.setMaterials( materials );
				objLoader.setPath( 'models/' );
				k++;
				//console.log(plantNamesTemp[k] + '.obj loading');
				objLoader.load( plantNamesTemp[k] + '.obj', function ( object ) {

					for (var i = 0 ; i <20; i++) {
						var clone = object.clone();
						clone.position.z += (Math.random()- 0.5) * 1000;
						clone.position.x += (Math.random()- 0.5) * 1000;
						//clone.traverse( function( node ) { if ( node instanceof THREE.Mesh ) { node.castShadow = true;node.receiveShadow = true; } } );
						objects.add( clone );

						if (j==plantNames.length&&treeFlag==0) {
							inportTrees();
						};
					}
				
				}, onProgress, onError );

			}, onProgress, onError);
		}
	}

	function inportTrees(){
		treeFlag =1;

		 var plantNames = new Array( 'ancient_oak_tree', 'large_oak_tree', 'large_pine_tree', 'mid_oak_tree', 'mid_pine_tree', 'sapling_oak_tree', 'small_oak_tree', 'small_pine_tree');
		//var plantNames = new Array( 'ancient_oak_tree');
		var plantNamesTemp = new Array;
		var k = -1;

		for(var j=0; j<plantNames.length; j++){//plantNames.length
			var mtlLoader = new THREE.MTLLoader();
			mtlLoader.setBaseUrl( 'models/' );
			mtlLoader.setPath( 'models/' );
			plantNamesTemp.push(plantNames[j]);
			console.log(plantNames[j] + '.mtl loading');
			mtlLoader.load( plantNames[j] + '.mtl', function( materials ) {
				materials.preload();

				var objLoader = new THREE.OBJLoader();
				objLoader.setMaterials( materials );
				objLoader.setPath( 'models/' );
				k++;
				console.log(plantNamesTemp[k] + '.obj loading');

				//objLoader.load( plantNamesTemp[k] + '.obj', function (object) {}, onProgress, onError );
				var t = k;
				objLoader.load( plantNamesTemp[k] + '.obj', function (object) {
			//object.rotation.x += Math.PI/2;

			object.scale.set(5,5,5);



			//adding tree
			treesPos[t].forEach(function(item,index){
				var clone = object.clone();
				clone.traverse( function( node ) { if ( node instanceof THREE.Mesh ) { node.castShadow = true;node.receiveShadow = true; } } );
				trees.push(object.clone());
				var hitbox = new Physijs.BoxMesh(new THREE.CubeGeometry( 34, 100, 34), new THREE.MeshBasicMaterial({transparent: true, opacity: 0}),0);
				hitbox.renderOrder = 1;
				hitbox.position.copy(clone.position);
				hitbox.position.x = item[0];
				hitbox.position.z = item[1];
				//hitbox.castShadow = true;
				hitbox.name="tree";
				scene.add(hitbox);
				hitbox.add(clone);
				if (j==plantNames.length&&readyFlag==0) {
				};
			 });
			
		}, onProgress, onError );

			}, onProgress, onError);
		}
	}
}



function createSelf(data){

	//"cast" a spell(which causes lag when first casted) into the ground at the begining
	// dummy = new THREE.Mesh(new THREE.CubeGeometry( 5,5,5), new THREE.MeshBasicMaterial());
	// dummy.add(bulbLight.clone());
	// dummy.position.y += 100;
	// scene.add(dummy);

	hitboxSelf = new Physijs.CapsuleMesh(new THREE.CylinderGeometry( 8,8, 30, 13), new THREE.MeshBasicMaterial({transparent: true, opacity: 0}), 10);
    hitboxSelf.addEventListener( 'collision', function( other_object, relative_velocity, relative_rotation, contact_normal ) {
        if(other_object.name == "fall"){
        //hud.log("collllied","red");
        iDie("himself");
        }
    });
	hitboxSelf.name = myselfinfo.name;
	//hitboxSelf.position.y = 500;
	hitboxSelf.position.x = myselfinfo.pos.x;
	hitboxSelf.position.z = myselfinfo.pos.z;
	hitboxSelf.position.y = 16;
	scene.add(hitboxSelf);
	hitboxSelf.setLinearVelocity(new THREE.Vector3(0,-10,0));
	myselfinfo.hp = 100;
	if(job != myselfinfo.job){
	switch (myselfinfo.job){
		case 'warrior':
			//add body and head
			controls.getObjectPitch().add(warriorShield);

			var warriorSelfBody = warriorBody.clone();
			warriorSelfBody.position.y -= 6;
			controls.getObjectPitch().add(warriorSelfBody);
			//add behavior
			var blocking = false;
			var onKeyDown = function ( event ) {
				if(status=="dead")
					return;
				switch( event.keyCode ) {
					case 81: // e
					if(blocking == false){
						shieldBlock();
					}
					blocking = true;
					break;
				}
			};
			var onKeyUp = function ( event ) {

				if(status=="dead")
					return;
				switch( event.keyCode ) {
					case 81: // e
					releaseShield();
					blocking = false;
					break;
				}
			};
			document.addEventListener( 'keydown', onKeyDown, false );
			document.addEventListener( 'keyup', onKeyUp, false );
			break;

		case 'mage':
			var fired = true;
		
			var onKeyDown = function ( event ) {
				if(status=="dead")
					return;
				switch( event.keyCode ) {
					case 69: // e
					if(cooldown>100)
						if (fired == true){
							cooldown-=100;
							socket.emit("castSpell",{name : myselfinfo.name,size:spellInfo.size});
							fired = false;
						}
					
					break;
					case 70: // e
					if(cooldown>300&&fired == true){
						cooldown-=300;
						fireFocus = true;
						scene.add(magicCircle);
						fired = false;
					}
					
					break;
				}
			};
			var onKeyUp = function ( event ) {
				if(status=="dead")
					return;
				switch( event.keyCode ) {
					case 69: // e
					//releaseSpell(myselfinfo.name,spellInfo.speed);
					if(fired == false){
					myreleaseSpell("normal");
					fired = true;
					}
					break;
					case 70: // f
						if(fireFocus){
						fireFocus = false;
						scene.remove(magicCircle);
						myreleaseSpell("super");
						
					}
					fired = true;
					break;
				}
			};
			document.addEventListener( 'keydown', onKeyDown, false );
			document.addEventListener( 'keyup', onKeyUp, false );
			break;
		}
		job = myselfinfo.job;
		}

	}

	function addPlayers(data){
		console.log('adding player');

		// players.forEach(function(item,index,object){
		// 	if(item.name == data.name)
		// 		return;
		// });

		var cloneBody, cloneHead, cloneSield;

		
		var hitbox = new Physijs.CapsuleMesh(new THREE.CylinderGeometry( 8, 8, 30, 13), new THREE.MeshBasicMaterial({transparent: true, opacity: 0}));
		// var hitbox = new THREE.Mesh(new THREE.CubeGeometry( 13, 30, 13), new THREE.MeshBasicMaterial({transparent: true, opacity: 0.5}));
		hitbox.position.copy(data.pos);
		console.log(data.pos);
		hitbox.name = data.name;
		hitbox.hp = data.hp;
		hitbox.type = "player";
		hitbox.rotation.copy(data.rot);


// var hitbox2 = new Physijs.BoxMesh(new THREE.CubeGeometry( 13, 30, 13), new THREE.MeshBasicMaterial({transparent: true, opacity: 1}));
// 		hitbox2.rotation.copy(data.rot);
// 		hitbox2.position.copy(data.pos);
// 		scene.add(hitbox2);

		switch(data.job){
			case 'warrior':
			cloneBody = warriorBody.clone();
			cloneHead = warriorHead.clone();
			break;
			case 'mage':
			cloneBody = warriorBody.clone();
			cloneHead = warriorHead.clone();
			break;
		}
		
		
		cloneBody.position.y += 5;
		//cloneHead.position.y += 45;
		//cloneHead.rotation.copy(data.pitch);
		
		
		
		//hitbox.position.y += 5;
		cloneBody.add(cloneHead);
		cloneHead.rotation.copy(data.rotHead);
		hitbox.add(cloneBody);
		
		

		var nameCanvas = document.createElement('canvas');
		nameCanvas.width = 512;
		nameCanvas.height = 128;

		var nameBitmap = nameCanvas.getContext('2d');
		nameBitmap.font = "Normal 70px Arial";
		nameBitmap.textAlign = 'center';
		nameBitmap.fillStyle = "rgba(245,245,245,0.75)";
		nameBitmap.fillText(hitbox.name, nameCanvas.width/2, nameCanvas.height/2);

		var nameTexture = new THREE.Texture(nameCanvas);
		nameTexture.needsUpdate = true;

		var nameMaterial = new THREE.MeshBasicMaterial( {map: nameTexture} );
		nameMaterial.transparent = true;

		// var nameMaterial = new THREE.SpriteMaterial( {map: nameTexture} );
		// var nameTag = new THREE.Sprite(nameMaterial);
		// scene.add(nameTag);

		var nameGeometry = new THREE.PlaneGeometry( nameCanvas.width, nameCanvas.height );
		var nameTagBack = new THREE.Mesh( nameGeometry, nameMaterial );
		var nameTagFront = new THREE.Mesh( nameGeometry, nameMaterial );
		nameTagBack.scale.set(0.1,0.1,0.1);
		nameTagFront.scale.set(0.1,0.1,0.1);
		nameTagBack.position.y += 20;
		nameTagFront.position.y += 20;
		nameTagFront.rotation.y += Math.PI;
		nameTagFront.position.y += 5;
		nameTagBack.position.y += 5;
		hitbox.add( nameTagBack );
		hitbox.add( nameTagFront );


		// players.forEach(function(item,index,object){
		// 	if(item.name == data.name){
		// 		console.log("repeated");
		// 		return;
		// 	}
				
		// });

		

		if(scene.getObjectByName(data.name) == null){
			scene.add(hitbox);
			players.push(hitbox);
		}
		console.log('added player');
	}

	function movePlayers(data){
		players.forEach(function(item,index,object){
			if (item.name == data.name) {
				//item.__dirtyRotation = true;
				//item.__dirtyPosition = true;
				// moveItem(item, data.pos);
				//rotItem(item, data.rot);

				//item.position.copy(data.pos);
				item.setAngularVelocity(new THREE.Vector3(0,0,0));
				item.__dirtyRotation = true;
				item.rotation.copy(data.rot);
				var head = item.getObjectByName('head');
				head.rotation.copy(data.rotHead);
				//console.log(data.rot);
				var targetPos = new THREE.Vector3(data.pos.x,data.pos.y,data.pos.z);

				//var targetRot = new THREE.Vector3(data.rot.x,data.rot.y,data.rot.z);

				item.setLinearVelocity(targetPos.sub(item.position).multiplyScalar(15));
				//item.setAngularVelocity( new THREE.Vector3(0,0,0));

				item.getObjectByName('shield').position.z = data.shieldPos;
			};
		});
	}

	function removePlayer(data){
		players.forEach(function(item,index,object){
			if (item.name == data.name) {
				
							options3.position.x = item.position.x;
							options3.position.y = item.position.y;
							options3.position.z = item.position.z;
							for (var x = 0; x < 1000; x++) {
								particleSystem.spawnParticle(options3);
							}
						

				scene.remove(item);
				players.splice(index, 1);

				

			};
		});
	}

</script>

<script>
	function iDie(killer){
		console.log("I die");
		socket.emit('i die', killer);
		scene.remove(hitboxSelf);
		status = "dead";
		document.exitPointerLock();
		//controls.enabled = false;
		//controls.dispose();
		//controls.enabled = false;
		//scene.remove(controls.getObject());
		// blocker.style.display = '-webkit-box';
		// blocker.style.display = '-moz-box';
		// blocker.style.display = 'box';
		// instructions.style.display = '';
		 continuePage.style.display = 'none';
		 statingPage.style.display = '';

	};

</script>

<script name = 'mage moves'>
				var bulbGeometry = new THREE.SphereGeometry( 0.02, 16, 8 );
				var bulbLight = new THREE.PointLight( 0xf04000, 3, 100, 2 );
				bulbLight.castShadow = true;
				var bulbMat = new THREE.MeshStandardMaterial( {
					emissive: 0xffffee,
					emissiveIntensity: 0.1,
					color: 0xFF0000
				});
				var firemesh = new THREE.Mesh( bulbGeometry, bulbMat );
				bulbLight.add(firemesh);

				var superBulbLight = new THREE.PointLight( 0xf04000, 1, 10000, 0.1 );
				superBulbLight.castShadow = true;
				superBulbLight.add(firemesh);

	function myreleaseSpell(type){
		if(type=="normal")
			socket.emit("releaseSpell",{name : myselfinfo.name,speed :spellInfo.speed, dir:controls.getDirection()});
		if(type=="super")
			if(intersecPoint[0]!=null)
				socket.emit("releaseSuperSpell",{name : myselfinfo.name,x :intersecPoint[0].point.x ,z :intersecPoint[0].point.z});
	}
	function releaseSpell(name,speed,dir,id){
	
		
		// var scar = new THREE.Mesh(new THREE.CubeGeometry( 2, 2, 2), new THREE.MeshBasicMaterial({color : 0x000000}));
		// scar.position.copy(intersection.point);
		// scene.add(scar);

		var spell;
		var head;

		if (myselfinfo.name==name){
			head = controls.getObjectPitch();
			//console.log("releaseSpell fireball");
		}else{
			players.forEach(function(item,index,object){
			if (item.name == name) {
					head = item;
				};
			});
		}

		spell = head.getObjectByName('fireball');
		spell.getObjectByName('sound').play();
		//console.log('releaseSpell! OWNER: ' + spell.owner);

		var pos = new THREE.Vector3();
		var rot = new THREE.Vector4();
		pos.setFromMatrixPosition(spell.matrixWorld);
		head.remove(spell);
		spell.position.copy(pos);
		//spell.id = id;
		spell.damage = spellInfo.damage;
		//spell.position.z -= 100;
		scene.add(spell);
		dir  = new THREE.Vector3(dir.x,dir.y,dir.z);
		movingSpells.push(spell);
		spell.setLinearVelocity(dir.multiplyScalar(speed*5));
		spell.addEventListener( 'collision', function( other_object, relative_velocity, relative_rotation, contact_normal ) {
			//console.log(other_object);
			//console.log(other_object+'|'+relative_velocity+"|"+relative_rotation+"|"+contact_normal+"|"+this);
			//console.log(spell.name+" hit "+other_object.name + "(owner : "+spell.owner+")"+other_object.owner);



			if(other_object.name == 'fireball'){
				movingSpells.forEach(function(item,index,object){
					if (item.uuid == spell.uuid ) {
						movingSpells.splice(index, 1);
					};
				})
				movingSpells.forEach(function(item,index,object){
					if (item.uuid == other_object.uuid  ) {
						movingSpells.splice(index, 1);
					};
				})
				scene.remove(other_object);
				scene.remove(spell);
				return;
			}
			if (spell.owner != other_object.name ) {
								
							options.position.x = spell.position.x;
							options.position.y = spell.position.y;
							options.position.z = spell.position.z;
							for (var x = 0; x < 1000; x++) {
								particleSystem.spawnParticle(options);
							}

				movingSpells.forEach(function(item,index,object){
					if (item.uuid == spell.uuid ||item.uuid == other_object.uuid  ) {
						movingSpells.splice(index, 1);
					};
				});

				console.log("hit!!"+spell.owner+" "+other_object.name);
				scene.remove(spell);
				if(other_object.name == myselfinfo.name){
		  		//socket.emit('hit', );
		  		myselfinfo.hp -= spell.damage;
		  		if(myselfinfo.hp <= 0){
		  			iDie(spell.owner);
		  		}
		  		console.log(spell.damage);
		  	}
			};
		  	
	
		});


	}

	function releaseSuperSpell(name,x,z){
	
		var spellEffect = new THREE.Mesh(new THREE.SphereGeometry(60, 32, 32 ), superFireballMat);
		var spell = new  Physijs.SphereMesh(new THREE.SphereGeometry(5, 5, 5 ),
			new THREE.MeshBasicMaterial({transparent:true, opacity:0.1}),1000);
		spell.name = 'superFireball';
		spell.damage = 2;
		spell.owner = name;
		spell.position.z = z;
		spell.position.x = x;
		spell.position.y = 200;
		spell.rotation.z -= Math.PI/2;
		//console.log(fireball.position);
		var dir  = new THREE.Vector3(0,-1,0);
		movingSpells.push(spell);
		movingCores.push(spell);
		spell.add(spellEffect);
		spellEffect.add(superBulbLight.clone());
		//var soundClone = sound.clone();
		
		var sound = new THREE.Audio3D({"url" : "sounds/boom.mp3", "reciever" : hitboxSelf, "onload": playWhenLoaded, "radius": 500});
		sound.name = 'sound';
		spell.add(sound);
		
		scene.add(spell);
		//spell.setLinearVelocity(dir.multiplyScalar(100));

		spell.addEventListener( 'collision', function( other_object, relative_velocity, relative_rotation, contact_normal ) {
			//console.log(other_object);
			//console.log(other_object+'|'+relative_velocity+"|"+relative_rotation+"|"+contact_normal+"|"+this);
			//console.log(spell.name+" hit "+other_object.name + "(owner : "+spell.owner+")"+other_object.owner);



			if(other_object.name == 'fireball'){
				movingSpells.forEach(function(item,index,object){
					if (item.uuid == other_object.uuid  ) {
						movingSpells.splice(index, 1);
					};
				})
				scene.remove(other_object);
				//scene.remove(spell);
				return;
			}
			if(other_object.name == 'superFireball'){
				movingSpells.forEach(function(item,index,object){
					if (item.uuid == spell.uuid ) {
						movingSpells.splice(index, 1);
					};
				})
				movingSpells.forEach(function(item,index,object){
					if (item.uuid == other_object.uuid  ) {
						movingSpells.splice(index, 1);
					};
				})
				movingCores.forEach(function(item,index,object){
					if (item.uuid == other_object.uuid  ) {
						movingCores.splice(index, 1);
					};
				})
				movingCores.forEach(function(item,index,object){
					if (item.uuid == spell.uuid  ) {
						movingCores.splice(index, 1);
					};
				})

				scene.remove(other_object);
				scene.remove(spell);
				return;
			}

			if (true) {

				movingSpells.forEach(function(item,index,object){
					if (item.uuid == spell.uuid ||item.uuid == other_object.uuid  ) {
						movingSpells.splice(index, 1);
					};
				});

				movingCores.forEach(function(item,index,object){
					if (item.uuid == spell.uuid ||item.uuid == other_object.uuid  ) {
						movingCores.splice(index, 1);
					};
				});


				console.log("hit!!"+spell.owner+" "+other_object.name);
				console.log(spell.getObjectByName('sound'));
				spell.getObjectByName('sound').play();

				scene.remove(spell);
				// if(other_object.name == myselfinfo.name){
		  // 		//socket.emit('hit', );
		  // 		myselfinfo.hp -= spell.damage;
		  	// 	if(myselfinfo.hp <= 0){
		  	// 		iDie(spell.owner);
		  	// 	}
		  	// 	console.log(spell.damage);
		  	// }
			};
		  	
	
		});


	}

	function castSpell(name,size){
		//var fireball = new  THREE.Mesh(new THREE.SphereGeometry( 5, 32, 32), new THREE.MeshLambertMaterial({color : 0xff0000}));

		

		//var fireball = new  Physijs.SphereMesh(new THREE.SphereGeometry(size, 34, 34 ), new THREE.MeshLambertMaterial({color : 0xff0000, transparent: true, opacity: 0}),spellInfo.mass);
		var fireball = new  Physijs.SphereMesh(new THREE.SphereGeometry(size, 34, 34 ), fireballMat,
			spellInfo.mass);
		//Ball.position.y += 100;
		//scene.add(Ball);
		fireball.name = 'fireball';
		fireball.owner = name;
		var sound = new THREE.Audio3D({"url" : "sounds/spell.mp3", "reciever" : hitboxSelf, "onload": playWhenLoaded, "radius": 500});
		sound.name = 'sound';
		fireball.add(sound);

		//controls.getObjectPitch().add(fireball);
		if (myselfinfo.name==name){
			controls.getObjectPitch().add(fireball);
			//console.log("name: " + name);
		}else{
			players.forEach(function(item,index,object){
			if (item.name == name) {
					item.add(fireball);
					//console.log("name: " + item.name);
				};
			});
		}
		//console.log(name +"castSpell");
		//fireball.owner = name;
		fireball.position.z -= 20;
		fireball.position.y -= 0;


				//bulbLight.add(firemesh);
				//bulbLight.position.set( 0, 10, 0 );
				//bulbLight.castShadow = true;
		//fireball.add( bulbLight );



	}
</script>


<script name = 'warrior moves'>
	function shieldBlock(){
		warriorShield.position.z -=10;
		myselfinfo.shieldPos = warriorShield.position.z;
	}

	function releaseShield(){
		// var head = controls.getObjectPitch();
		// head.remove(warriorShield);
		warriorShield.position.z += 10;
		myselfinfo.shieldPos = warriorShield.position.z;
	}
</script>
</body>
</html>
